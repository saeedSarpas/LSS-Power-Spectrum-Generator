void variance(double * power_array, int length, double * callback_results) {

	// callback results:
	// +-----------------------------+
	// | 0: mode power | 1: variance |
	// +-----------------------------+

	int i;

	callback_results[0] = 0.0f;

	for (i = 1; i <= length; i++) {
		callback_results[0] += power_array[i];
	}

	callback_results[0] /= length;

	callback_results[1] = 0.0f;

	for (i = 0; i < length; i++) {
		callback_results[1] += pow((power_array[i] - callback_results[0]), 2);
	}
}

void one_mode_ps (double mode_log, double mode_interval_log,
		fftw_complex * gird_fourier, double * callback_results) {

	// callback results:
	// +--------------------------+-----------------------------+
	// | 0: mode power | 1: error | 2: number of found elements |
	// +--------------------------+-----------------------------+

	int i, j, k, length = 0;
	double d_log, *power_array;
	fftw_complex *rho;
	allocate_fftw_complex_array(&rho, 1);
	power_array = calloc(pow(NUM_GRID_IN_EACH_AXIS , 3), sizeof(double));

	// Following we iterate through all negative and positive Fourier mode and
	// it is the job of rho_tilda function to return the right element of
	// the output of r2c FFTW transform

	int mid_grid = NUM_GRID_IN_EACH_AXIS / 2;

	// Here we iterate through following matrix.
	//
	//     +-----------------------------------------------------------+
	//     | -4,-4 | -4,-3 | -4,-2 | -4,-1 | -4,0 | -4,1 | -4,2 | -4,3 |
	//     +-----------------------------------------------------------+
	//     |       |       |       |       |      |      |      |      |
	//     +-----------------------------------------------------------+
	//     |       |       |       |       |      |      |      |      |
	//     +-----------------------------------------------------------+
	//     |       |       |       |       |      |      |      |      |
	//     +-----------------------------------------------------------+
	//     |  0,-4 |  0,-3 |  0,-2 |  0,-1 |  0,0 |  0,1 |  0,2 |  0,3 |
	//     +-----------------------------------------------------------+
	//     |  1,-4 |  1,-3 |  1,-2 |  1,-1 |  1,0 |  1,1 |  1,2 |  1,3 |
	//     +-----------------------------------------------------------+
	//     |  2,-4 |  2,-3 |  2,-2 |  2,-1 |  2,0 |  2,1 |  2,2 |  2,3 |
	//     +-----------------------------------------------------------+
	//     |  3,-4 |  3,-3 |  3,-2 |  3,-1 |  3,0 |  3,1 |  3,2 |  3,3 |
	//     +-----------------------------------------------------------+
	//
	// The ordering of this matrix is different from the return matrix of an r2c
	// FFTW. We should keep this in mind when we want to retrieve the Fourier
	// density contrast.
	//
	// The empty boxes are not generated by r2c FFTW. By using Hermitian
	// redundancy we can calculate these missing elements.

	int cntr = 0;
	for (i = - mid_grid; i < mid_grid; i++){
		for (j = - mid_grid; j < mid_grid; j++){
			for (k = - mid_grid; k < mid_grid; k++){
				d_log = log10(sqrt(pow(i, 2) + pow(j, 2) + pow(k, 2)));

				double min = mode_log - mode_interval_log;
				double max = mode_log + mode_interval_log;

				if (d_log >= min && d_log < max) {
					rho_tilda(i, j, k, gird_fourier, rho);
					power_array[length] += pow(creal(*rho), 2) + pow(cimag(*rho), 2);
					length++;
					cntr++;
				}
			}
		}
	}

	callback_results[2] = (float)cntr;

	if (length != 0) {
		double sigma_squared;
		variance(power_array, length, callback_results);
		callback_results[1] = sqrt(callback_results[1]) / length;
	} else {
		printf("\n[Find no point in this shell, mode= %f and mode_interval = %f]\n", pow(10, mode_log), pow(10, mode_interval_log));
		exit(0);
	}
}
